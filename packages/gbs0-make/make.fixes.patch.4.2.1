diff -u -r -w make-4.2.1/dir.c make-4.2.1-patched/dir.c
--- make-4.2.1/dir.c	2016-05-31 08:17:26.000000000 +0000
+++ make-4.2.1-patched/dir.c	2019-04-30 10:45:31.436407480 +0000
@@ -1299,15 +1299,40 @@
 }
 #endif
 
+/* Similarly for lstat.  */
+#if !defined(lstat) && !defined(WINDOWS32) || defined(VMS)
+# ifndef VMS
+#  ifndef HAVE_SYS_STAT_H
+int lstat (const char *path, struct stat *sbuf);
+#  endif
+# else
+    /* We are done with the fake lstat.  Go back to the real lstat */
+#   ifdef lstat
+#     undef lstat
+#   endif
+# endif
+# define local_lstat lstat
+#elif defined(WINDOWS32)
+/* Windows doesn't support lstat().  */
+# define local_lstat local_stat
+#else
+static int
+local_lstat (const char *path, struct stat *buf)
+{
+  int e;
+  EINTRLOOP (e, lstat (path, buf));
+  return e;
+}
+#endif
+
 void
 dir_setup_glob (glob_t *gl)
 {
   gl->gl_opendir = open_dirstream;
   gl->gl_readdir = read_dirstream;
   gl->gl_closedir = free;
+  gl->gl_lstat = local_lstat;
   gl->gl_stat = local_stat;
-  /* We don't bother setting gl_lstat, since glob never calls it.
-     The slot is only there for compatibility with 4.4 BSD.  */
 }
 
 void
diff -u -r -w make-4.2.1/posixos.c make-4.2.1-patched/posixos.c
--- make-4.2.1/posixos.c	2016-05-21 21:21:52.000000000 +0000
+++ make-4.2.1-patched/posixos.c	2019-04-30 10:45:44.145899640 +0000
@@ -59,6 +59,24 @@
 #endif
 }
 
+static void
+set_blocking (int fd, int blocking)
+{
+  // If we're not using pselect() don't change the blocking
+#ifdef HAVE_PSELECT
+  int flags;
+  EINTRLOOP (flags, fcntl (fd, F_GETFL));
+  if (flags >= 0)
+    {
+      int r;
+      flags = blocking ? (flags & ~O_NONBLOCK) : (flags | O_NONBLOCK);
+      EINTRLOOP (r, fcntl (fd, F_SETFL, flags));
+      if (r < 0)
+        pfatal_with_name ("fcntl(O_NONBLOCK)");
+    }
+#endif
+}
+
 unsigned int
 jobserver_setup (int slots)
 {
@@ -78,6 +96,9 @@
         pfatal_with_name (_("init jobserver pipe"));
     }
 
+  /* When using pselect() we want the read to be non-blocking.  */
+  set_blocking (job_fds[0], 0);
+
   return 1;
 }
 
@@ -113,6 +134,9 @@
       return 0;
     }
 
+  /* When using pselect() we want the read to be non-blocking.  */
+  set_blocking (job_fds[0], 0);
+
   return 1;
 }
 
@@ -161,7 +185,10 @@
 {
   unsigned int tokens = 0;
 
-  /* Close the write side, so the read() won't hang.  */
+  /* Use blocking reads to wait for all outstanding jobs.  */
+  set_blocking (job_fds[0], 1);
+
+  /* Close the write side, so the read() won't hang forever.  */
   close (job_fds[1]);
   job_fds[1] = -1;
 
@@ -239,18 +266,12 @@
 unsigned int
 jobserver_acquire (int timeout)
 {
-  sigset_t empty;
-  fd_set readfds;
   struct timespec spec;
   struct timespec *specp = NULL;
-  int r;
-  char intake;
+  sigset_t empty;
 
   sigemptyset (&empty);
 
-  FD_ZERO (&readfds);
-  FD_SET (job_fds[0], &readfds);
-
   if (timeout)
     {
       /* Alarm after one second (is this too granular?)  */
@@ -259,29 +280,53 @@
       specp = &spec;
     }
 
-  r = pselect (job_fds[0]+1, &readfds, NULL, NULL, specp, &empty);
+  while (1)
+    {
+      fd_set readfds;
+      int r;
+      char intake;
 
-  if (r == -1)
+      FD_ZERO (&readfds);
+      FD_SET (job_fds[0], &readfds);
+
+      r = pselect (job_fds[0]+1, &readfds, NULL, NULL, specp, &empty);
+      if (r < 0)
+        switch (errno)
     {
-      /* Better be SIGCHLD.  */
-      if (errno != EINTR)
-        pfatal_with_name (_("pselect jobs pipe"));
+          case EINTR:
+            /* SIGCHLD will show up as an EINTR.  */
       return 0;
+
+          case EBADF:
+            /* Someone closed the jobs pipe.
+               That shouldn't happen but if it does we're done.  */
+              O (fatal, NILF, _("job server shut down"));
+
+          default:
+            pfatal_with_name (_("pselect jobs pipe"));
     }
 
   if (r == 0)
     /* Timeout.  */
     return 0;
 
-  /* The read FD is ready: read it!  */
+      /* The read FD is ready: read it!  This is non-blocking.  */
   EINTRLOOP (r, read (job_fds[0], &intake, 1));
+
   if (r < 0)
+        {
+          /* Someone sniped our token!  Try again.  */
+          if (errno == EAGAIN)
+            continue;
+
     pfatal_with_name (_("read jobs pipe"));
+        }
 
-  /* What does it mean if read() returns 0?  It shouldn't happen because only
-     the master make can reap all the tokens and close the write side...??  */
+      /* read() should never return 0: only the master make can reap all the
+         tokens and close the write side...??  */
   return r > 0;
 }
+}
 
 #else
 
diff -u -r -w make-4.2.1/tests/run_make_tests.pl make-4.2.1-patched/tests/run_make_tests.pl
--- make-4.2.1/tests/run_make_tests.pl	2016-04-04 06:38:37.000000000 +0000
+++ make-4.2.1-patched/tests/run_make_tests.pl	2019-04-30 10:45:31.439199720 +0000
@@ -58,6 +58,9 @@
   *CORE::GLOBAL::rmdir = \&vms_rmdir;
 }
 
+use FindBin;
+use lib "$FindBin::Bin";
+
 require "test_driver.pl";
 require "config-flags.pm";
 

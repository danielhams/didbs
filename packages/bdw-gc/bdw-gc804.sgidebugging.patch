diff -u -r -w gc-8.0.4/alloc.c gc-8.0.4-patched/alloc.c
--- gc-8.0.4/alloc.c	2019-03-02 08:54:41.000000000 +0000
+++ gc-8.0.4-patched/alloc.c	2019-05-27 10:59:49.265649920 +0000
@@ -1225,6 +1225,8 @@
  */
 GC_INNER void GC_add_to_heap(struct hblk *p, size_t bytes)
 {
+  void *inp = p;
+  size_t inbytes = bytes;
     hdr * phdr;
     word endp;
 
@@ -1238,12 +1240,16 @@
         if (0 == bytes) return;
     }
     endp = (word)p + bytes;
+    GC_printf("DH1 inp=%p endp=%p p=%p inbytes=%lu bytes=%lu\n",
+	      inp, endp, p, inbytes, bytes);
     if (endp <= (word)p) {
         /* Address wrapped. */
         bytes -= HBLKSIZE;
         if (0 == bytes) return;
         endp -= HBLKSIZE;
     }
+    GC_printf("DH2 inp=%p endp=%p p=%p inbytes=%lu bytes=%lu\n",
+	      inp, endp, p, inbytes, bytes);
     phdr = GC_install_header(p);
     if (0 == phdr) {
         /* This is extremely unlikely. Can't add it.  This will         */
Only in gc-8.0.4-patched: alloc.c.orig
diff -u -r -w gc-8.0.4/mark.c gc-8.0.4-patched/mark.c
--- gc-8.0.4/mark.c	2019-03-02 08:54:41.000000000 +0000
+++ gc-8.0.4-patched/mark.c	2019-05-27 11:14:54.246424080 +0000
@@ -1260,6 +1260,8 @@
 
 GC_INNER void GC_scratch_recycle_inner(void *ptr, size_t bytes)
 {
+  GC_printf("DH scratch_recycle_inner of ptr=%p size=%lu\n",
+	    ptr, bytes);
   if (ptr != NULL) {
     size_t page_offset = (word)ptr & (GC_page_size - 1);
     size_t displ = 0;
@@ -1270,10 +1272,19 @@
     /* TODO: Assert correct memory flags if GWW_VDB */
     if (page_offset != 0)
       displ = GC_page_size - page_offset;
-    recycled_bytes = (bytes - displ) & ~(GC_page_size - 1);
+    GC_printf("DH bytes=%lu displ=%lu GC_page_size=%lu page_offset=%lu\n",
+	      bytes, displ, GC_page_size, page_offset);
+    //    recycled_bytes = (bytes - displ) & ~(GC_page_size - 1);
+    recycled_bytes = (bytes - displ) & (GC_page_size - 1);
+    GC_printf("DH Recycle %lu/%lu scratch-allocated bytes at %p\n",
+                       (unsigned long)recycled_bytes, (unsigned long)bytes,
+	      ptr);
     GC_COND_LOG_PRINTF("Recycle %lu/%lu scratch-allocated bytes at %p\n",
                        (unsigned long)recycled_bytes, (unsigned long)bytes,
                        ptr);
+    GC_printf("DH sizeof(word)=%lu recycled_bytes_sign=%s\n",
+	      sizeof(word),
+	      (recycled_bytes > 0 ? "+" : "-"));
     if (recycled_bytes > 0)
       GC_add_to_heap((struct hblk *)((word)ptr + displ), recycled_bytes);
   }
Only in gc-8.0.4-patched: mark.c.orig
Only in gc-8.0.4-patched: mark.c~
diff -u -r -w gc-8.0.4/tests/test.c gc-8.0.4-patched/tests/test.c
--- gc-8.0.4/tests/test.c	2019-03-02 08:54:41.000000000 +0000
+++ gc-8.0.4-patched/tests/test.c	2019-05-27 11:56:47.516139200 +0000
@@ -18,6 +18,8 @@
 /* GC.  It uses GC internals to allow more precise results      */
 /* checking for some of the tests.                              */
 
+#include <errno.h>
+
 # ifdef HAVE_CONFIG_H
 #   include "config.h"
 # endif
@@ -1505,16 +1507,30 @@
             FAIL;
           }
           if (print_stats)
-            GC_log_printf("Forked child process\n");
+            GC_log_printf("Forked child process %d\n", pid);
+	  int done=0;
+	  while(!done) {
+            GC_log_printf("Waiting for child process %d\n", pid);
           if (waitpid(pid, &wstatus, 0) == -1) {
-            GC_printf("Wait for child process failed\n");
+	      GC_printf("Wait for child process failed errno=%d\n",
+			errno);
             FAIL;
           }
-          if (!WIFEXITED(wstatus) || WEXITSTATUS(wstatus) != 0) {
+	    GC_printf("Child process waitpid, wifexited= %lu\n",
+		      WIFEXITED(wstatus));
+	    GC_printf("Child process waitpid, wexitstatus= %lu\n",
+		      WEXITSTATUS(wstatus));
+	    if (WIFEXITED(wstatus) == 0 && WEXITSTATUS(wstatus) != 0) {
             GC_printf("Child process failed, status= 0x%x\n", wstatus);
             FAIL;
           }
+	    if( WIFEXITED(wstatus) != 0 ) {
+	      done=1;
+	    }
+	  }
+	  GC_log_printf("Done waiting for child process %d\n", pid);
         } else {
+	  GC_printf("In the child pid is %d\n", pid);
           GC_atfork_child();
           if (print_stats)
             GC_log_printf("Started a child process\n");
@@ -1524,11 +1540,14 @@
 #           endif
             GC_start_mark_threads();
 #         endif
+	  GC_printf("In the child pid %d calling gcollect\n", pid);
           GC_gcollect();
+	  GC_printf("In the child pid %d after gcollect\n", pid);
 #         ifdef THREADS
             tiny_reverse_test(0);
             GC_gcollect();
 #         endif
+	  GC_printf("In the child pid %d after tiny reverse test\n", pid);
           if (print_stats)
             GC_log_printf("Finished a child process\n");
           exit(0);
Only in gc-8.0.4-patched/tests: test.c.orig
Only in gc-8.0.4-patched/tests: test.c~
diff -u -r -w gc-8.0.4/tests/test_atomic_ops.c gc-8.0.4-patched/tests/test_atomic_ops.c
--- gc-8.0.4/tests/test_atomic_ops.c	2019-03-02 08:54:41.000000000 +0000
+++ gc-8.0.4-patched/tests/test_atomic_ops.c	2019-05-27 10:59:49.283797920 +0000
@@ -48,7 +48,9 @@
         TA_assert(AO_test_and_set_acquire(&z) == AO_TS_SET);
         AO_CLEAR(&z);
 #   endif
+#if !defined(__sgi)
     AO_compiler_barrier();
+#endif
 #   ifdef AO_HAVE_nop_full
       AO_nop_full();
 #   endif
Only in gc-8.0.4-patched/tests: test_atomic_ops.c.orig
